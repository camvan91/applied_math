%!PS-Adobe-2.0 EPSF-2.0
%%BoundingBox: 0 0 288 288
%%Creator: Mathematica
%%CreationDate: Mon Sep 29 21:27:19 PDT 1997
%%EndComments
% Start of procedure set
userdict /Mathdict 100 dict dup begin put
% The externally visible functions are:
%	MathPictureStart- start page.
%	MathPictureEnd	- finish off page.
%	MathSubStart	- start a sub-page.
%	MathSubEnd	- finish off a sub-page.
%	Mdot		- draw a dot.
%	Mtetra		- draw a filled tetragon.
%	Metetra		- draw a filled tetragon with black edges.
%	Mistroke	- intermediate stroke of multi-stroke line/curve.
%	Mfstroke	- final stroke of multi-stroke line/curve.
%	Msboxa		- compute coordinates of text bounding box.
%	Mshowa		- plot characters.
%	MathScale	- compute scaling info to contain array of points.
%start of ISOLatin1 stuff
/ISOLatin1Encoding dup where
{ pop pop }
{
[
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright
/parenleft /parenright /asterisk /plus /comma /minus /period /slash
/zero /one /two /three /four /five /six /seven
/eight /nine /colon /semicolon /less /equal /greater /question
/at /A /B /C /D /E /F /G
/H /I /J /K /L /M /N /O
/P /Q /R /S /T /U /V /W
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore
/quoteleft /a /b /c /d /e /f /g
/h /i /j /k /l /m /n /o
/p /q /r /s /t /u /v /w
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/dotlessi /grave /acute /circumflex /tilde /macron /breve /dotaccent
/dieresis /.notdef /ring /cedilla /.notdef /hungarumlaut /ogonek /caron
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section
/dieresis /copyright /ordfeminine /guillemotleft
/logicalnot /hyphen /registered /macron
/degree /plusminus /twosuperior /threesuperior
/acute /mu /paragraph /periodcentered
/cedilla /onesuperior /ordmasculine /guillemotright
/onequarter /onehalf /threequarters /questiondown
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis
] def
} ifelse
/MFontDict 50 dict def
/MStrCat
{
exch
dup length
2 index length add
string
dup 3 1 roll
copy
length
exch dup
4 2 roll exch
putinterval
} bind def
/MCreateEncoding
{
1 index
255 string cvs
(-) MStrCat
1 index MStrCat
cvn exch
(Encoding) MStrCat
cvn dup where
{
exch get
}
{
pop
StandardEncoding
} ifelse
3 1 roll
dup MFontDict exch known not
{
1 index findfont
dup length dict
begin
{1 index /FID ne
{def}
{pop pop}
ifelse} forall
/Encoding 3 index
def
currentdict
end
1 index exch definefont pop
MFontDict 1 index
null put
}
if
exch pop
exch pop
} bind def
/ISOLatin1 { (ISOLatin1) MCreateEncoding } bind def
%end of ISOLatin1 stuff
% Set up for the start of a page.
/MathPictureStart {
/Msaveobj save def
/findresource where
{ pop /WRI-Mathematica-prolog /ProcSet findresource begin }
{ Mathdict begin }
ifelse
userdict begin
/MathPictureStartHook where {
/MathPictureStartHook get exec
} if
Mtransform
Mlmarg
Mbmarg
translate
Mwidth
Mlmarg Mrmarg add
sub
/Mwidth exch def
Mheight
Mbmarg Mtmarg add
sub
/Mheight exch def
/Mtmatrix
matrix currentmatrix
def
/Mgmatrix
matrix currentmatrix
def
/MathDPSFlag where {
pop
clientsync
} if
} def
% Finish off a page.
/MathPictureEnd {
end
end
Msaveobj restore
/MathDPSFlag where { pop } { showpage } ifelse
} def
%MFill fills the drawing area with the current color.
/MFill {
0 0 		moveto
Mwidth 0 	lineto
Mwidth Mheight 	lineto
0 Mheight 	lineto
fill
} def
%New device-specific optimizing operators
/Mfill /.devicefill where
{ pop /.devicefill load def }
{ /fill load def }
ifelse
/Mstroke /.devicestroke where
{ pop /.devicestroke load def }
{ /stroke load def }
ifelse
% xmin xmax ymin ymax MPlotRegion alters the origin, Mwidth and Mheight 
% so that the picture fills the altered region
/MPlotRegion {
3 index
Mwidth mul
2 index
Mheight mul
translate
exch sub
Mheight mul
/Mheight
exch def
exch sub
Mwidth mul
/Mwidth
exch def
} def
% Given a rectangle, set it up as a sub-picture.
/MathSubStart {
Momatrix
Mgmatrix Mtmatrix
Mwidth Mheight
7 -2 roll
moveto
Mtmatrix setmatrix
currentpoint
Mgmatrix setmatrix
9 -2 roll
moveto
Mtmatrix setmatrix
currentpoint
2 copy translate
/Mtmatrix matrix currentmatrix def
3 -1 roll
exch sub
/Mheight exch def
sub
/Mwidth exch def
} def
% Restore the saved state left by the matching MathSubStart.
% Note, we also leave with the new Mgmatrix as the current matrix.
/MathSubEnd {
/Mheight exch def
/Mwidth exch def
/Mtmatrix exch def
dup setmatrix
/Mgmatrix exch def
/Momatrix exch def
} def
% Given a point, draw a dot.
/Mdot {
newpath
currentlinewidth 2 div
0 360
arc fill
} bind def
% Given 4 points, draw the corresponding filled tetragon.
/Mtetra {
moveto
lineto
lineto
lineto
Mfill
} bind def
% Given 4 points, draw the corresponding filled tetragon with black edges.
% Note, this leaves the gray level at 0 (for compatibility with the old
% C code.
/Metetra {
moveto
lineto
lineto
lineto
closepath
gsave
Mfill
grestore
0 setgray
Mstroke
} bind def
% Mistroke is called to stroke intermediate parts of a path.  It makes
% sure to resynchronize the dashing pattern and to leave the current point
% as the final point of the path.
/Mistroke {
flattenpath
0 0 0
{
4 2 roll
pop pop
}
{
4 -1 roll
2 index
sub dup mul
4 -1 roll
2 index
sub dup mul
add sqrt
4 -1 roll
add
3 1 roll
}
{
stop
}
{
stop
}
pathforall
pop pop
currentpoint
Mstroke
moveto
currentdash
3 -1 roll
add
setdash
} bind def
% Mfstroke is called to stroke the final parts of a path.  It resets
% the dashing pattern to compensate for any adjustments made by Mistroke.
/Mfstroke {
Mstroke
currentdash
pop 0
setdash
} bind def
% Mrotsboxa is the same as Msboxa except that it takes an angle 
% from the stack and the box is calculated for text rendered at this  angle.  
% It gsaves in case we are starting a MathSubStart
% save Mrot so that Msboxa can convert bouding box back to the non-rotated
% coordinate system
% call Mrotcheck to alter the offsets into the rotated system
% converts Mtmatrix to render in the rotated system
% the calls Msboxa which does all the work
% at the end  Mtmatrix is restored and Mrot is reset to 0 
/Mrotsboxa {
gsave
dup
/Mrot
exch def
Mrotcheck
Mtmatrix
dup
setmatrix
7 1 roll
4 index
4 index
translate
rotate
3 index
-1 mul
3 index
-1 mul
translate
/Mtmatrix
matrix
currentmatrix
def
grestore
Msboxa
3  -1 roll
/Mtmatrix
exch def
/Mrot
0 def
} bind def
% Given an array of strings ([str...]), which represent consecutive lines
% of text, a position in graphics coordinates (gx,gy) and a position in
% the bounding box coordinates (sx,sy), compute the low and high coordinates
% of the resulting text, in the [gx gy tx ty] form, which corresponds to
% the point (gx,gy) (in graphics coordinates) plus the offset (tx,ty) (in
% text coordinates).
% Note, Msboxa assumes that the current matrix is the text matrix.
% Mboxout is called in case we are in Mouter to make the box bigger
% Mboxrot adjusts the box to account for a rotation to convert the box
% into a nonrotated coordinate system
%
/Msboxa {
newpath
5 -1 roll
Mvboxa
pop
Mboxout
6 -1 roll
5 -1 roll
4 -1 roll
Msboxa1
5 -3 roll
Msboxa1
Mboxrot
[
7 -2 roll
2 copy
[
3 1 roll
10 -1 roll
9 -1 roll
]
6 1 roll
5 -2 roll
]
} bind def
% Msboxa1 is an internal function which, given a bounding box coordinate
% (sz), and the bounding box limits (blz and bhz), computes the actual
% offsets (tlz = (blz-bhz)(sz+1)/2, thz = (blz-bhz)(sz-1)/2).
/Msboxa1 {
sub
2 div
dup
2 index
1 add
mul
3 -1 roll
-1 add
3 -1 roll
mul
} bind def
% Given a (non-empty) array of strings ([str...]) which represent consecutive
% lines of text, compute the total bounding box assuming that we start at
% (0,0) and the array of y offsets to place the lines correctly.
% Note, Mvboxa assumes that the current matrix is the text matrix.
% Note, Mvboxa does not alter the current path.
% The vertical spacing is set so that the bounding boxes of adjacent lines
% are .3 times the width of an `m' apart.
/Mvboxa {
gsave
newpath
[ true
3 -1 roll
{
Mbbox
5 -1 roll
{
0
5 1 roll
}
{
7 -1 roll
exch sub
(m) stringwidth pop
.3 mul
sub
7 1 roll
6 -1 roll
4 -1 roll
Mmin
3 -1 roll
5 index
add
5 -1 roll
4 -1 roll
Mmax
4 -1 roll
}
ifelse
false
}
forall
{ stop } if
counttomark
1 add
4 roll
]
grestore
} bind def
% Given a string, compute the bounding box assuming that we start at (0,0).
% Note, the path is assumed to be empty, and we are assumed to be in text
% coordinates.  Allows for long strings.
/Mbbox {
1 dict begin
0 0 moveto
/temp (T) def
{	gsave
currentpoint newpath moveto
temp 0 3 -1 roll put temp
false charpath flattenpath currentpoint
pathbbox
grestore moveto lineto moveto} forall
pathbbox
newpath
end
} bind def
% Compute the minimum of two numbers.
/Mmin {
2 copy
gt
{ exch } if
pop
} bind def
% Compute the maximum of two numbers.
/Mmax {
2 copy
lt
{ exch } if
pop
} bind def
%
% Mrotwork saves Mrot (not really needed but saved anyway)
% calls Mrotcheck to adjust the offsets into the rotated coordinate system
% converts Mtmatrix to render in the rotated system
%
/Mrotwork {
dup
/Mrot
exch def
Mrotcheck
Mtmatrix
dup
setmatrix
7 1 roll
4 index
4 index
translate
rotate
3 index
-1 mul
3 index
-1 mul
translate
/Mtmatrix
matrix
currentmatrix
def
Mgmatrix setmatrix
} def
%
% Mrotshowa is the same as Mshowa except that it takes an angle
% from the stack and the text is rendered at this angle.
% It call Mrotwork to do all the rotation work.
% Then it calls Mshowa which does all the drawing work.
% At the end Mtmatrix is restored and Mrot is reset to zero.
%
/Mrotshowa {
Mrotwork
Mshowa
/Mtmatrix
exch def
/Mrot 0 def
} def
%
% Draws rotated text with a background.
%
/Mrotback {
7 1 roll
dup
8 1 roll
Mrotwork
8 -2 roll
Mshowback
/Mtmatrix
exch def
/Mrot 0 def
} def
%
% Given an array of strings ([str...]), which represent consecutive lines
% of text, a position in graphics coordinates (gx,gy) and a position in
% the bounding box coordinates (sx,sy), display the strings.
% Mboxout is called in case we are in Mouter
%
/Mshowa {
4 -2 roll
moveto
2 index
Mtmatrix setmatrix
Mvboxa
7 1 roll
Mboxout
6 -1 roll
5 -1 roll
4 -1 roll
Mshowa1
4 1 roll
Mshowa1
rmoveto
currentpoint
Mshowax
pop pop pop pop
Mgmatrix setmatrix
} def
%
% The background box of text is increased by the
% size of an "m"
%
/Madjust	{
(m)
stringwidth
pop
mul
dup
4 -1 roll
add
3 1 roll
add
} def
%
%
%
/Mbuildcoord {
7 index
7 index
4 -1 roll
4 -1 roll
index
exch
index
Mabsadd
} def
%
% If the text is rotated then translate to the drawing point.
% Rotate then translate back.  Do not do this if the angle
% of rotation is 0.
%
/Mrotate {
8 index
0 ne
{
13 copy
4 -2 roll
pop pop
6 -2 roll
pop pop
4 -1 roll
3 -1 roll
sub
6 -1 roll
mul
3 1 roll
sub
4 -1 roll
mul
3 -1 roll
5 1 roll
Mabsadd
2 copy
translate
3 -1 roll
rotate
exch -1 mul
exch -1 mul
translate
} if
9 -1 roll
pop
} def
%
% Draw text but into a box with a certain color.
% Uses Msboxa to build the box.
%
/Mshowback {
gsave
exec
6 copy pop
Msboxa
aload pop
0.5 Madjust
5 -1 roll
aload pop
Mrotate
-0.5
Madjust
4 -1 roll
pop
3 -1 roll
pop
3 4
Mbuildcoord
moveto
3 4
Mbuildcoord
lineto
3 6
Mbuildcoord
lineto
5 6
Mbuildcoord
lineto
5 4
Mbuildcoord
lineto
pop pop pop
pop pop pop
fill		
grestore
Mshowa
} def
% This is used for fixedwidth fonts
% It simply shows each string and advances the y direction by the offset
%
/Mshowax {	
0 1
4 index length
-1 add
{
2 index
4 index
2 index
get
3 index
add
moveto
4 index
exch get
Mfixdash
{
Mfixdashp		
}
if
show
} for
} def
% Fix if all dashes and length > 1
/Mfixdashp {
dup
length
1
gt
1 index
true exch
{
45
eq
and
} forall
and
{
gsave
(--)		
stringwidth pop
(-)
stringwidth pop
sub
2 div
0 rmoveto
dup
length
1 sub
{
(-)
show
}
repeat
grestore
}
if
} bind def	
% Mshowa1 is an internal routine which, given a bounding box coordinate
% (sz), and the bounding box limits if we started drawing at 0 (tlz and thz),
% computes the offset at which to start drawing
% (relz = (sz-1)tlz/2 - (sz+1)thz/2 = sz(tlz-thz)/2-(tlz+thz)/2).
/Mshowa1 {
2 copy
add
4 1 roll
sub
mul
sub
-2 div
} bind def
% Given the x and y scaling to user coordinates and an array of points to
% fit (xbias xscale ybias yscale [pnts]), set up the scaling.  The array
% must contain atleast two points, and the last two must be of the form
% [gxlow gylow 0 0] and [gxhigh gyhigh 0 0].
% Note, MathScale assumes that we are already scaled so that the active area
% is the rectangle [0,Mwidth-Mlmarg-Mrmarg]x[0,Mheight-Mbmarg-Mtmarg].
% also keep bias and scale info for PostScript commands
/MathScale {
Mwidth
Mheight
Mlp
/MathScaleHook where {
/MathScaleHook get exec
} if
translate
scale
pop pop pop pop
pop pop pop pop
/yscale exch def
/ybias exch def
/xscale exch def
/xbias exch def
/Momatrix
xscale yscale matrix scale
xbias ybias matrix translate
matrix concatmatrix def
/Mgmatrix
matrix currentmatrix
def
} def
% Given a non-empty array of points to fit ([p]) and a maximum width (sx)
% and height (sy) find the largest scale (Ax and Ay) and offsets (Bx and By)
% such that the transformation
%	[gx gy tx ty] -> (Ax gx + tx + bx, Ay gy + ty + By)
% maps the points into the rectangle [0,sx]x[0,sy]
/Mlp {
3 copy
Mlpfirst
{
Mnodistort
{
Mmin
dup
} if
4 index
2 index
2 index
Mlprun
16 -8 roll
21 8 roll
11 index
11 -1 roll
10 -4 roll
Mlp1
8 index
9 -5 roll
Mlp1
4 -1 roll
and
{ exit } if
15 -8 roll
pop pop pop pop
pop pop pop pop
3 -1 roll
pop pop
} loop
exch
3 1 roll
7 -3 roll
pop pop pop
} def
% Given an array of points in the [gx gy tx ty] form, with the last two
% being [gxlow gylow 0 0] and [gxhigh gyhigh 0 0], and the width and height
% (sx and sy) in which to fit them, compute the maximum scaling (Ax and Ay).
/Mlpfirst {
3 -1 roll
dup length
2 copy
-2 add
get
aload
pop pop pop
4 -2 roll
-1 add
get
aload
pop pop pop
6 -1 roll
3 -1 roll
5 -1 roll
sub
div
4 1 roll
exch sub
div
} bind def
% Given a non-empty array of points to fit ([pnts]) and scale factors
% for graphics->text (Ax and Ay), compute the limiting points.
/Mlprun {
2 copy
4 index
0 get
dup
4 1 roll
Mlprun1
3 copy
8 -2 roll
9 -1 roll
{
3 copy
Mlprun1
3 copy
11 -3 roll
/gt Mlpminmax
8 3 roll
11 -3 roll
/lt Mlpminmax
8 3 roll
} forall
pop pop pop pop
3 1 roll
pop pop
aload pop
5 -1 roll
aload pop
8 copy
exch
6 -1 roll
Mlprun2
8 2 roll
4 -1 roll
Mlprun2
6 2 roll
3 -1 roll
Mlprun2
4 2 roll
exch
Mlprun2
6 2 roll
} bind def
% Given scale factors for graphics->text (Ax and Ay) and a point in the
% [gx gy tx ty] form, return the text x and y coordinate that results.
/Mlprun1 {
aload pop
exch
6 -1 roll
5 -1 roll
mul add
4 -2 roll
mul
3 -1 roll
add
} bind def
% Given a low and high coordinate, compute the center and width.
/Mlprun2 {
2 copy
add 2 div
3 1 roll
exch sub
} bind def
% Given two points stored as [gx gy tx ty] followed by the scaled
% result (rx, ry), and a comparison function (lt or gt) leave the
% point which is the minimum (or maximum) in each dimension.
/Mlpminmax {
cvx
2 index
6 index
2 index
exec
{
7 -3 roll
4 -1 roll
} if
1 index
5 index
3 -1 roll
exec
{
4 1 roll
pop
5 -1 roll
aload
pop pop
4 -1 roll
aload pop
[
8 -2 roll
pop
5 -2 roll
pop
6 -2 roll
pop
5 -1 roll
]
4 1 roll
pop
}
{
pop pop pop
} ifelse
} bind def
% Given a size (s), graphics->text scale (A), text center (ct), text
% width (wt), graphics center (cg) and graphics width (wg), compute
% a new graphics->text scale (Anew) and offset (B) and whether or not
% we are done.
% Note, the mysterious .99999 is magic juju which is supposed to ward
% off the possibility that floating point errors would cause this
% routine to return the old A and yet claim not-done.
/Mlp1 {
5 index
3 index	sub
5 index
2 index mul
1 index
le
1 index
0 le
or
dup
not
{
1 index
3 index	div
.99999 mul
8 -1 roll
pop
7 1 roll
}
if
8 -1 roll
2 div
7 -2 roll
pop sub
5 index
6 -3 roll
pop pop
mul sub
exch
} bind def
% The following are the workings of the tick, axes and plot labels.
% NOTE a possible source of confusion is that for xticks ie tickmarks on
% the x axis we keep y information and vice versa for yticks
%
%	When Minner is found then
%
% assumes that box starts at zero on the left lower side
%
%		0)	if outflag = 1 then intop = 0, inrht = 0 outflag = 0
%		1)	Save intop 	largest top of box 
%		2)	Save inrht 	largest rht of box
%		3)	set inflag	notifies that inner marks are present
%
%	When Mouter is found then
%
%	if inflag is set then
%		1)	get vecx and vecy off the stack (points in direcn to move)
%		2)	vecx < 1 xadrht = inrht*abs(vecx)
%		3)	vecx > 1 xadlft = inrht*abs(vecx)
%		4)	vecy < 1 yadtop = intop*abs(vecy)
%		5)	vecy > 1 yadbot = intop*abs(vecy)
%		6)	set outflag = 1
%		7)	clear inflag, inrht, intop
%	guaranteed to be zero if no inner is present??
%
%
%	These all have effects in Mrotsboxa and Mrotshowa
%		check inflag and if set
%
%		1) increase top of bbox by yadtop
%		2) decrease bot of bbox by yadbot
%		3) increase rht of bbox by xadrht
%		4) increase lft of bbox by xadlft
%		5) clear outflag, yadtop, yadbot,
%			         xadrht, xadlft
%
% 
% This saves the top right corner of the bounding box as a side effect
% This is to allow the adjustment of text placed with Mouter so that
% it misses the Minner text.  It is assumed that the ang is 0
% in the same way it is assumed that the text of Mouter is 0 or 90
%
/Minner {
outflag
1
eq
{
/outflag 0 def
/intop 0 def
/inrht 0 def
} if		
5 index
gsave
Mtmatrix setmatrix
Mvboxa pop
grestore
3 -1 roll
pop
dup
intop
gt
{
/intop
exch def
}
{ pop }
ifelse
dup
inrht
gt
{
/inrht
exch def
}
{ pop }
ifelse
pop
/inflag
1 def
} def
% This takes two number off the stack and uses them as a vector in graphics
% coordinates which points in the direction in which the Mouter text is to move
% it calculates the bouding box adjustments yadtop yadbot xadrht and xadlft
% these are in Mboxout to adjust the bounding box to compensate.
/Mouter {
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
inflag
1 eq
{
dup
0 lt
{
dup
intop
mul
neg
/yadtop
exch def
} if
dup
0 gt
{
dup
intop
mul
/yadbot
exch def
}
if
pop
dup
0 lt
{
dup
inrht
mul
neg
/xadrht
exch def
} if
dup
0 gt
{
dup
inrht
mul
/xadlft
exch def
} if
pop
/outflag 1 def
}
{ pop pop}
ifelse
/inflag 0 def
/inrht 0 def
/intop 0 def
} def	
%
% This adjusts the bounding box to account for adjacent text
% This allows the two text strings to avoid each other 
% current matrix is the text matrix
/Mboxout {
outflag
1
eq
{
4 -1
roll
xadlft
leadjust
add
sub
4 1 roll
3 -1
roll
yadbot
leadjust
add
sub
3 1
roll
exch
xadrht
leadjust
add
add
exch
yadtop
leadjust
add
add
/outflag 0 def
/xadlft 0 def
/yadbot 0 def
/xadrht 0 def
/yadtop 0 def
} if
} def
/leadjust {
(m) stringwidth pop
.5 mul
} bind def
% The offsets sx and sy refer to the graphics coordinate system 
% thus they must be altered if a rotation has taken place.
% We must also change the bounding box computations for Minner
%
/Mrotcheck {
dup
90
eq
{
%
% Mouter only applies to strings which are either at 0 or 90
% sort out the box adjust factors
%
%	xadrht -> yadbot
%	xadlft -> yadtop
%	yadtop -> xadrht
%	yadbot -> xadlft
yadbot
/yadbot
xadrht
def	
/xadrht
yadtop
def
/yadtop
xadlft
def
/xadlft
exch
def
}
if
dup
cos
1 index
sin
Checkaux
dup
cos
1 index
sin neg
exch
Checkaux
3 1 roll
pop pop
} def
%
% Checkaux is an auxilliary function for Mrotcheck it multiplies a 
% row vector by a column vector
% 
/Checkaux {
4 index
exch
4 index
mul
3 1 roll
mul add
4 1 roll
} bind def
%
% Mboxrot converts the bounding box back from the rotated coordinate
% system to the Mgmatrix system to compensate for a rotation
% It has the opposite functionality of Mrotcheck
% This is not the most neatest or most efficient implementation but it works
%
/Mboxrot {
Mrot
90 eq
{
% old		 tlx  thx  tly  thy
% new		-thy -tly  tlx  thx
%
brotaux
4 2
roll
}
if
Mrot
180 eq
{
% old		 tlx  thx  tly  thy
% new		-thx -tlx -thx -tly
%
4 2
roll
brotaux
4 2
roll
brotaux
}	
if
Mrot
270 eq
{
% old		 tlx  thx  tly  thy
% new		 tly  thy -thx -tlx
%
4 2
roll
brotaux
}
if
} def
%
% auxilliary function negate and reverse
/brotaux {
neg
exch
neg
} bind def
%
% Mabsproc takes a measurement in the default user units and converts
% it to the present units.   This allows absolute thickness and dashing
% to work.  It works by using a {0, x} vector and using the RMS of the result.
/Mabsproc {
0
matrix defaultmatrix
dtransform idtransform
dup mul exch
dup mul
add sqrt
} bind def
%
% Mabswid allows the linewidth to be specified in absolute coordinates
% It does this by recording the graphics transformation matrix at the
% begining of the plot.
% This will break if the scaling in the x and y directions is
% different.  This is the case if Mnodistort is false
%
/Mabswid {
Mabsproc
setlinewidth	
} bind def
% Mabsdash allows the dashing pattern to be specified in absolute coordinates
% It does this by recording the graphics transformation matrix at the
% begining of the plot.
% This will break if the scaling in the x and y directions is
% different.  This is the case if Mnodistort is false
%
/Mabsdash {
exch
[
exch
{
Mabsproc
}
forall
]
exch
setdash
} bind def
%
% Mabs takes a pair of coordinates in points
% and converts them into a pair of coordinates in
% the current drawing scheme
%
/Mabs {
Mgmatrix idtransform
Mtmatrix dtransform
} bind def
%
% Mabs takes a pair of numbers in drawing coordinates
% and a pair in points.  It converts the points to
% drawing coordinates and adds them to the first pair.
%
/Mabsadd {
Mabs
3 -1 roll add
3 1 roll add
exch 
} bind def
%
% These two procedures are for using Offset coordinates
% with MathScale computations
%
/Mabsfix1 {
3 -1 roll
/ar exch 
def
ar 2 get
3 -1 roll
add exch
ar 3 get
add
ar 3
3 -1 roll
put
ar 2
3 -1 roll
put
ar
} bind def
/Mabsfix {
2 copy
6 -1 roll
3 1 roll
Mabsfix1
4 1 roll
Mabsfix1
} bind def
%MBeginOrig start coordinates in user coordinates
/MBeginOrig { Momatrix concat} bind def
%MEndOrig start coordinates in user coordinates
/MEndOrig { Mgmatrix setmatrix} bind def
/sampledsound where
{ pop }
{ /MathDPSFlag where
{ pop /sampledsound { clientsync } def }
{ /sampledsound {
exch pop
exch 5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} def
} ifelse
} ifelse
% Define setrgbcolor for those ancient PostScript devices lacking it
/setrgbcolor dup where
{ pop pop }
{ { .114 mul exch .587 mul add exch .299 mul add setgray } bind def }
ifelse
%
% now simple conversion of cmykcolor to rgbcolor
% subtract k and then take complements
/setcmykcolor where
{ pop}
{ /setcmykcolor {
4 1
roll
[
4 1 
roll
]
{
1 index
sub
1
sub neg
dup
0
lt
{
pop
0
}
if
dup
1
gt
{
pop
1
}
if
exch
} forall
pop
setrgbcolor
} bind def
} ifelse
% Here are the short operators
/g /setgray load def
/k /setcmykcolor load def
/m /moveto load def
/p /gsave load def
/r /setrgbcolor load def
/w /setlinewidth load def
/C /curveto load def
/F /Mfill load def
/L /lineto load def
/P /grestore load def
/s /Mstroke load def
/Mcharproc
{
currentfile
(x)
readhexstring
pop
0 get
exch
div
} bind def
/Mshadeproc
{
dup
3 1
roll
{
dup
Mcharproc
3 1
roll
} repeat
1 eq
{
setgray
}
{
3 eq
{
setrgbcolor
}
{
setcmykcolor
} ifelse
} ifelse
} bind def
/Mrectproc
{
3 index
2 index
moveto
2 index
3 -1
roll
lineto
dup
3 1
roll
lineto
lineto
Mfill
} bind def
/Mcolorimage
{
7 1
roll
pop
pop
matrix
invertmatrix
concat
2 exch exp
1 sub
3 1 roll
1 1
2 index
{
1 1
4 index
{
dup
1 sub
exch
2 index
dup
1 sub
exch
7 index
9 index
Mshadeproc
Mrectproc
} for
pop
} for
pop pop pop pop
} bind def
/Mimage
{
pop
matrix
invertmatrix
concat
2 exch exp
1 sub
3 1 roll
1 1
2 index
{
1 1
4 index
{
dup
1 sub
exch
2 index
dup
1 sub
exch
7 index
Mcharproc
setgray
Mrectproc
} for
pop
} for
pop pop pop
} bind def
% Default values for variables
/Mlmarg		0 72 mul def
/Mrmarg		0 72 mul def
/Mbmarg		0 72 mul def
/Mtmarg		0 72 mul def
/Mwidth		4.0 72 mul def
/Mheight	4.0 72 mul def
/Mtransform	{  } bind def
/Mnodistort	true def	
/Mfixdash	false def	
/Mrot		0	def	
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/defineresource where
{ pop /WRI-Mathematica-prolog currentdict /ProcSet defineresource pop }
if
end
%KLUDGE until Mathematica output uses resources directly
userdict /MathPictureStart {
	/findresource where
	{ pop /WRI-Mathematica-prolog /ProcSet findresource }
	{ Mathdict }
	ifelse
	/MathPictureStart get exec
} put
%%AspectRatio: .61803 
MathPictureStart
/Mabs {
Mgmatrix idtransform
Mtmatrix dtransform
} bind def
/Mabsadd { Mabs
3 -1 roll add
3 1 roll add
exch } bind def
%% Graphics
/Courier findfont 10  scalefont  setfont
% Scaling calculations
0.5 0.5 0.309017 0.309017 [
[0 .29652 -6 -9 ]
[0 .29652 6 0 ]
[.125 .29652 -15 -9 ]
[.125 .29652 15 0 ]
[.25 .29652 -12 -9 ]
[.25 .29652 12 0 ]
[.375 .29652 -15 -9 ]
[.375 .29652 15 0 ]
[.625 .29652 -12 -9 ]
[.625 .29652 12 0 ]
[.75 .29652 -9 -9 ]
[.75 .29652 9 0 ]
[.875 .29652 -12 -9 ]
[.875 .29652 12 0 ]
[1 .29652 -3 -9 ]
[1 .29652 3 0 ]
[1.025 .30902 0 -7.5 ]
[1.025 .30902 10 7.5 ]
[.4875 0 -12 -4.5 ]
[.4875 0 0 4.5 ]
[.4875 .07725 -30 -4.5 ]
[.4875 .07725 0 4.5 ]
[.4875 .15451 -24 -4.5 ]
[.4875 .15451 0 4.5 ]
[.4875 .23176 -30 -4.5 ]
[.4875 .23176 0 4.5 ]
[.4875 .38627 -24 -4.5 ]
[.4875 .38627 0 4.5 ]
[.4875 .46353 -18 -4.5 ]
[.4875 .46353 0 4.5 ]
[.4875 .54078 -24 -4.5 ]
[.4875 .54078 0 4.5 ]
[.4875 .61803 -6 -4.5 ]
[.4875 .61803 0 4.5 ]
[.5 .64303 -5 0 ]
[.5 .64303 5 15 ]
[ 0 0 0 0 ]
[ 1 .61803 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
0 g
.25 Mabswid
[ ] 0 setdash
0 .30902 m
0 .31527 L
s
[(-1)] 0 .29652 0 1 Mshowa
.125 .30902 m
.125 .31527 L
s
[(-0.75)] .125 .29652 0 1 Mshowa
.25 .30902 m
.25 .31527 L
s
[(-0.5)] .25 .29652 0 1 Mshowa
.375 .30902 m
.375 .31527 L
s
[(-0.25)] .375 .29652 0 1 Mshowa
.625 .30902 m
.625 .31527 L
s
[(0.25)] .625 .29652 0 1 Mshowa
.75 .30902 m
.75 .31527 L
s
[(0.5)] .75 .29652 0 1 Mshowa
.875 .30902 m
.875 .31527 L
s
[(0.75)] .875 .29652 0 1 Mshowa
1 .30902 m
1 .31527 L
s
[(1)] 1 .29652 0 1 Mshowa
.125 Mabswid
.025 .30902 m
.025 .31277 L
s
.05 .30902 m
.05 .31277 L
s
.075 .30902 m
.075 .31277 L
s
.1 .30902 m
.1 .31277 L
s
.15 .30902 m
.15 .31277 L
s
.175 .30902 m
.175 .31277 L
s
.2 .30902 m
.2 .31277 L
s
.225 .30902 m
.225 .31277 L
s
.275 .30902 m
.275 .31277 L
s
.3 .30902 m
.3 .31277 L
s
.325 .30902 m
.325 .31277 L
s
.35 .30902 m
.35 .31277 L
s
.4 .30902 m
.4 .31277 L
s
.425 .30902 m
.425 .31277 L
s
.45 .30902 m
.45 .31277 L
s
.475 .30902 m
.475 .31277 L
s
.525 .30902 m
.525 .31277 L
s
.55 .30902 m
.55 .31277 L
s
.575 .30902 m
.575 .31277 L
s
.6 .30902 m
.6 .31277 L
s
.65 .30902 m
.65 .31277 L
s
.675 .30902 m
.675 .31277 L
s
.7 .30902 m
.7 .31277 L
s
.725 .30902 m
.725 .31277 L
s
.775 .30902 m
.775 .31277 L
s
.8 .30902 m
.8 .31277 L
s
.825 .30902 m
.825 .31277 L
s
.85 .30902 m
.85 .31277 L
s
.9 .30902 m
.9 .31277 L
s
.925 .30902 m
.925 .31277 L
s
.95 .30902 m
.95 .31277 L
s
.975 .30902 m
.975 .31277 L
s
.25 Mabswid
0 .30902 m
1 .30902 L
s
gsave
1.025 .30902 -61 -11.5 Mabsadd m
1 1 Mabs scale
currentpoint translate
0 23 translate 1 -1 scale
63.000000 15.000000 moveto
%%IncludeResource: font Courier
%%IncludeFont: Courier
/Courier findfont 10.000000 scalefont
[1 0 0 -1 0 0 ] makefont setfont
0.000000 0.000000 0.000000 setrgbcolor
0.000000 0.000000 rmoveto
63.000000 15.000000 moveto
%%IncludeResource: font Courier
%%IncludeFont: Courier
/Courier findfont 10.000000 scalefont
[1 0 0 -1 0 0 ] makefont setfont
0.000000 0.000000 0.000000 setrgbcolor
(y) show
69.000000 15.000000 moveto
%%IncludeResource: font Courier
%%IncludeFont: Courier
/Courier findfont 10.000000 scalefont
[1 0 0 -1 0 0 ] makefont setfont
0.000000 0.000000 0.000000 setrgbcolor
0.000000 0.000000 rmoveto
1.000000 setlinewidth
%%DocumentNeededResources: font Courier
%%DocumentSuppliedResources:
%%DocumentNeededFonts: Courier
%%DocumentSuppliedFonts:
%%DocumentFonts: font Courier
grestore
.5 0 m
.50625 0 L
s
[(-1)] .4875 0 1 0 Mshowa
.5 .07725 m
.50625 .07725 L
s
[(-0.75)] .4875 .07725 1 0 Mshowa
.5 .15451 m
.50625 .15451 L
s
[(-0.5)] .4875 .15451 1 0 Mshowa
.5 .23176 m
.50625 .23176 L
s
[(-0.25)] .4875 .23176 1 0 Mshowa
.5 .38627 m
.50625 .38627 L
s
[(0.25)] .4875 .38627 1 0 Mshowa
.5 .46353 m
.50625 .46353 L
s
[(0.5)] .4875 .46353 1 0 Mshowa
.5 .54078 m
.50625 .54078 L
s
[(0.75)] .4875 .54078 1 0 Mshowa
.5 .61803 m
.50625 .61803 L
s
[(1)] .4875 .61803 1 0 Mshowa
.125 Mabswid
.5 .01545 m
.50375 .01545 L
s
.5 .0309 m
.50375 .0309 L
s
.5 .04635 m
.50375 .04635 L
s
.5 .0618 m
.50375 .0618 L
s
.5 .09271 m
.50375 .09271 L
s
.5 .10816 m
.50375 .10816 L
s
.5 .12361 m
.50375 .12361 L
s
.5 .13906 m
.50375 .13906 L
s
.5 .16996 m
.50375 .16996 L
s
.5 .18541 m
.50375 .18541 L
s
.5 .20086 m
.50375 .20086 L
s
.5 .21631 m
.50375 .21631 L
s
.5 .24721 m
.50375 .24721 L
s
.5 .26266 m
.50375 .26266 L
s
.5 .27812 m
.50375 .27812 L
s
.5 .29357 m
.50375 .29357 L
s
.5 .32447 m
.50375 .32447 L
s
.5 .33992 m
.50375 .33992 L
s
.5 .35537 m
.50375 .35537 L
s
.5 .37082 m
.50375 .37082 L
s
.5 .40172 m
.50375 .40172 L
s
.5 .41717 m
.50375 .41717 L
s
.5 .43262 m
.50375 .43262 L
s
.5 .44807 m
.50375 .44807 L
s
.5 .47898 m
.50375 .47898 L
s
.5 .49443 m
.50375 .49443 L
s
.5 .50988 m
.50375 .50988 L
s
.5 .52533 m
.50375 .52533 L
s
.5 .55623 m
.50375 .55623 L
s
.5 .57168 m
.50375 .57168 L
s
.5 .58713 m
.50375 .58713 L
s
.5 .60258 m
.50375 .60258 L
s
.25 Mabswid
.5 0 m
.5 .61803 L
s
gsave
.5 .64303 -66 -4 Mabsadd m
1 1 Mabs scale
currentpoint translate
0 23 translate 1 -1 scale
63.000000 15.000000 moveto
%%IncludeResource: font Courier
%%IncludeFont: Courier
/Courier findfont 10.000000 scalefont
[1 0 0 -1 0 0 ] makefont setfont
0.000000 0.000000 0.000000 setrgbcolor
0.000000 0.000000 rmoveto
63.000000 15.000000 moveto
%%IncludeResource: font Courier
%%IncludeFont: Courier
/Courier findfont 10.000000 scalefont
[1 0 0 -1 0 0 ] makefont setfont
0.000000 0.000000 0.000000 setrgbcolor
(x) show
69.000000 15.000000 moveto
%%IncludeResource: font Courier
%%IncludeFont: Courier
/Courier findfont 10.000000 scalefont
[1 0 0 -1 0 0 ] makefont setfont
0.000000 0.000000 0.000000 setrgbcolor
0.000000 0.000000 rmoveto
1.000000 setlinewidth
%%DocumentNeededResources: font Courier
%%DocumentSuppliedResources:
%%DocumentNeededFonts: Courier
%%DocumentSuppliedFonts:
%%DocumentFonts: font Courier
grestore
0 0 m
1 0 L
1 .61803 L
0 .61803 L
closepath
clip
newpath
.5 Mabswid
1 0 m
.92216 .02507 L
.84477 .05241 L
.77921 .07809 L
.72269 .10279 L
.66953 .12908 L
.6252 .15438 L
.58544 .18128 L
.55429 .20719 L
.53096 .23212 L
.52163 .24474 L
.51329 .25864 L
.50724 .27182 L
.50513 .27773 L
.50323 .28417 L
.50239 .28767 L
.50172 .29091 L
.50114 .29427 L
.50072 .29731 L
.5004 .30031 L
.50028 .30168 L
.50018 .30313 L
.5001 .30468 L
.50007 .30537 L
.50004 .30611 L
.50002 .30691 L
.50001 .30765 L
.5 .3081 L
.5 .30853 L
.5 .30933 L
.50001 .31007 L
.50002 .31087 L
.50004 .31162 L
.50006 .31231 L
.50013 .31391 L
.50023 .3156 L
.50035 .31725 L
.5005 .31878 L
.50092 .32225 L
.50189 .32803 L
.50332 .33421 L
.50531 .34085 L
.50798 .34806 L
.51422 .36114 L
.52213 .37403 L
.53241 .38769 L
.55583 .41228 L
.58773 .43845 L
.6252 .46365 L
.67233 .49043 L
Mistroke
.72484 .51624 L
.78192 .54106 L
.84975 .56747 L
.92195 .59289 L
1 .61803 L
Mfstroke
% End of Graphics
MathPictureEnd
